## npm 包管理工具及运行原理

### 终端命令

#### 命令解析器
通过命令解析器，接受命令字符串，解析并执行对应指令。

常见解析器：
+ shell：Unix操作系统下的命令解析器
+ bash：Linux操作系统下的命令解析器
+ cmd：Windows 命令解释器
+ PowerShell：一种跨平台的任务自动化和配置管理框架，由命令行管理程序和脚本语言组成。(win10 默认提供)

#### 命令执行流程

1. 判断命令路径
2. 判断是内部命令还是外部命令（内部命令常驻内存，如`ls`,`cd`）
3. 不是内部命令，又没有包含命令路径。需要去**系统环境变量PATH**配置目录去找

### 以Node语句执行为例

以windows为例，安装完node后会自动给系统的 PATH 环境变量配置了一个 `node.exe` 文件所在的目录路径。这样我们在终端输入 `node -v` 命令，那么就会进行我们上面说到的那些步骤，最终会在 PATH 环境变量配置的目录中找到 `node.exe` 执行命令，然后进行相关的程序执行。

基于此原理我们也可以下载不同版本的 Node 文件，然后需要用到**不同版本**的 Node 时，就手动设置不同版本的 `node.exe` 文件所在的目录路径到系统的 PATH 环境变量上。从而也可以达到手动切换 Node 版本的目的。例如大名鼎鼎的 Node 版本管理工具 `nvm` 切换不同版本 Node 的原理也源于此。

### npm run 发生了什么？

#### 安装npm命令

以windows环境为例，一般安装node时，集成安装了npm。设置环境变量，把 npm 命令文件所在的目录设置到系统的 PATH 环境变量上。这样在命令终端输入 npm 的时候，就可以通过系统的 PATH 环境变量上配置的目录路径找到对应的 npm 命令文件了。然后系统就会把 npm 命令文件中的内容读取到内存中，就可以执行了。

#### 全局命令和局部命令

**全局安装**

以 typescript 为例，进行全局安装：`npm install typescript -g`

就获得了一个全局命令 tsc。我们就可以在终端输入 tsc 开头的命令。这是因为我们执行上面的命令代码之后会在系统变量 PATH 中设置的 node 命令所在的目录上写入了以下命令文件：`tsc, tsc.cmd, tsc.ps1`

在终端输入 tsc -v 命令之后，命令解析器就可以通过系统变量 PATH 中设置目录路径找到对应的 tsc 命令。

**局部安装**

`npm install typescript -D`，前面上面看到的那三个命令文件就会出现在当前目录的 `./node_modules/.bin` 文件目录下。

这个时候我们是不能直接通过终端执行 tsc 命令的，因为此时 tsc 命令文件所在的目录并没有在系统变量 PATH 中进行设置。

#### npm scripts的本质

可以在 `package.json` 文件的 `scripts` 选项中进行自定义脚本，然后通过 `npm run xxx` 来执行。原理就是 `npm run` 会创建一个 `shell` 脚本，`package.json` 文件的 `scripts` 选项中自定义的脚本内容就会在这个新创建的 `shell` 脚本中运行。

### npm install 发生了什么？

`npm run` 主要是执行 `package.json` 中 `scripts` 选项定义的脚本，而 `npm install` 则是用来**安装项目依赖**。

执行 npm install 命令之后，当前项目如果定义了 `preinstall` 钩子此时会被执行。之后会获取 npm 配置，即 `.npmrc` 文件。

优先级为：项目级的 .npmrc 文件 > 用户级的 .npmrc 文件 > 全局的 .npmrc 文件 > npm 内置的 .npmrc 文件。

然后检查项目根目录中有没有 `package-lock.json` 文件，如果有 `package-lock.json` 文件，则检查 `package-lock.json` 文件和 `package.json` 文件中声明的版本是否一致。

+ 一致，直接使用 `package-lock.json` 文件中的信息，从**缓存或从网络仓库**中加载依赖。
+ 不一致，根据npm版本安装。`npm v5.4.2` 以上： 按照 package.json 安装，并更新 package-lock.json。
+ 没有 `package-lock.json` 文件，则根据 `package.json` 文件**递归构建依赖树**，然后按照构建好的依赖树下载完整的依赖资源，在下载时会检查是否有相关缓存。
  + 有，则将缓存内容解压到 node_modules 目录中。
  + 没有，则先从 npm 远程仓库下载包资源，检查包的完整性，并将其添加到缓存，同时解压到 node_modules 目录中。
+ 最后生成 package-lock.json 文件。项目如果定义了 `postinstall` 钩子此时会被执行。

构建依赖树时，首先将项目根目录的 package.json 文件中 dependencies 和 devDependencies 选项的依赖按照首字母（@排最前）进行排序，排好序后 npm 会开启多进程从每个首层依赖模块向下递归获取子依赖。这样便获得一棵完整的依赖树，其中可能包含大量**重复依赖**。

现代包管理工具采用扁平化结构解决重复包的问题：当多个软件包对同一个依赖包有不同的版本要求时，包管理工具会尽可能选择一个共同的版本来满足所有软件包的需求，或者在不同软件包之间使用不同版本的依赖包的**兼容版本**。

#### 关于 package.json 和 package-lock.json

+ package.json是用来记录项目的**基本信息和依赖项的清单**，而package-lock.json是用来记录当前安装的依赖项的**确切版本号和依赖关系树**
+ package.json文件是**手动维护**的，开发人员可以使用npm或yarn等工具手动添加、删除或更新依赖项。它还可以包含一些其他的配置信息，如脚本命令、作者、许可证等。
+ package-lock.json文件是**自动生成**的，它会在执行npm install或yarn install命令时自动更新。它的作用是**确保在不同的开发环境中，安装的依赖项是一致**的。它记录了每个依赖项的确切版本号和依赖关系树，以及安装过程中使用的**镜像源和缓存**等信息，以便在重现项目时保持一致性。

> 为什么 `yarn-lock.json`, `package-lock.json`都有镜像源地址（`register`），而 `pnpm-lock.yaml`却没有？

+ pnpm并不会直接使用镜像源来下载依赖项，而是使用一种称为 `shrinkwrap` 的机制来记录依赖项的版本和依赖关系。
+ 如果**本地缓存中不存在所需的依赖**项，pnpm会根据pnpm-lock.yaml文件中记录的版本号和依赖关系，从npm仓库下载对应的依赖项。pnpm会**自动选择一个合适的镜像源**来下载依赖项，通常会使用npm的默认镜像源。如果需要使用其他镜像源，可以通过设置环境变量或者在pnpm的配置文件中进行配置。

### 幽灵依赖和pnpm

Element Plus 项目在 `.npmrc` 文件中主要配置了两项内容：`shamefully-hoist=true` 和 `strict-peer-dependencies=false`。

`shamefully-hoist = true` 选项是因为幽灵依赖问题而设置的，**幽灵依赖：项目的依赖关系中存在未在项目的依赖清单**，这些依赖项可能是由于安装其他依赖项时自动安装的，或者是由于项目的依赖关系发生了变化而残留下来的。

> pnpm 如何解决幽灵依赖？

项目的 package.json 文件中显示声明的依赖则会平铺在 `node_modules` 根目录下，而**依赖中依赖**则放在 `node_modules` 根目录下的 .`pnpm` 的目录中 `node_modules` 目录下。这样由于 幽灵依赖 包没有直接暴露在 node_modules 根目录下，则项目中就不能再进行引用使用了，这样也就解决了幽灵依赖的问题。

> `shamefully-hoist = true` 的意义

在使用 pnpm 包管理器时，`shamefully-hoist = true` 的作用是将**所有依赖项安装在项目根目录的 node_modules 文件夹中，而不是将它们分别安装在各个子目录的 node_modules 文件夹中**。

默认情况下，pnpm 会在每个项目子目录中创建一个独立的 node_modules 文件夹，这样可以避免依赖项之间的冲突。然而，这也会导致磁盘空间的浪费和安装时间的增加。

通过设置 shamefully-hoist = true，pnpm 可以将所有依赖项安装在项目根目录的 node_modules 文件夹中，以减少磁盘空间的使用和提高安装速度。这样做可能会导致一些依赖项之间的冲突，因为它们共享相同的顶层依赖项，所以这个选项被称为 "shamefully-hoist"（无耻提升）。




## Icon组件的实现

### 目录结构确定

所有组件的都按照下面的结构划分

~~~bash
├── packages
│   ├── components
│   │   ├── icon
│   │   │   ├── __tests__       # 测试目录
│   │   │   ├── src             # 组件入口目录
│   │   │   │   ├── icon.ts     # 组件属性与 TS 类型
│   │   │   │   └── icon.vue    # 组件模板内容
│   │   │   ├── style           # 组件样式目录
│   │   │   └── index.ts        # 组件入口文件
│   │   └── package.json
~~~

`icon.ts` 和 `icon.vue`抽离，是因为vue3 `Composition API` 的优势。可以把组件的属性和TS类型抽离放在一个独立的文件夹，方便后期维护。

Vue2 没有 Composition API 之前 Vue 相关业务的代码需要配置到 Option 的特定的区域，导致代码可复用性不高

### 定义组件属性 Prop

Element Plus的Icon组件只有两个Prop属性：
+ `color`：svg的填充色
+ `size`: svg图标大小

我们希望父组件传递给子组件的prop的类型是符合要求的，可以采用vue提供的prop验证机制：

验证的类型（type）可以是下列原生构造函数中的一个：
+ String
+ Number
+ Boolean
+ Array
+ Object
+ Date
+ Function
+ Symbool

~~~ts
export const iconProps = {
  color: String,
  size: [Number, String], // size 可以是数字，也可以是字符串
} as const

// 实际上推断出来是下面的类型：why？
// const iconProps: {
//   readonly color: StringConstructor;
//   readonly size: readonly [NumberConstructor, StringConstructor];
// }
~~~

`as const` 是 TS 的语法，它告诉 TS 它所断言的值以及该值的所有层级的子属性都是不可篡改的。

TS中类型有两种`静态类型`和`实例类型`。`String` 只是一个构造函数，并不是 TypeScript 中的 `string` 类型，String 构造函数在 TypeScript 的类型是它的构造函数类型： `StringConstructor` ，但这并不是我们需要的，我们希望 String 构造函数返回的是字符串类型 `string`。

~~~ts
import type { ExtractPropTypes, PropType } from 'vue'

export const iconProps = {
  color: String,
  size: [Number, String] as PropType<number | string>,
} as const

export type Props = ExtractPropTypes<typeof iconProps>
~~~

Vue3提供了自带的Props类型声明: `ExtractPropTypes`，可以接受一个类型，把对应的所接收的 props 类型返回出来，同时如果是构造函数类型则转换成对应的类型，比如 StringConstructor 转换成 string。

~~~TS
const propsOptions = {
  foo: String,
  bar: Boolean,
  baz: {
    type: Number,
    required: true
  },
  qux: {
    type: Number,
    default: 1
  }
} as const

type Props = ExtractPropTypes<typeof propsOptions>
// {
//   foo?: string,
//   bar: boolean,
//   baz: number,
//   qux: number
// }
~~~

`PropType`用于在用运行时 `props` 声明时给一个 `prop` 标注更**复杂**的类型定义，因为验证类型只能是构造函数中的几个:

~~~ts
interface Book {
  title: string
  author: string
  year: number
}

export default {
  props: {
    book: {
      // 提供一个比 `Object` 更具体的类型
      type: Object as PropType<Book>,
      required: true
    }
  }
}
~~~

最后我们还需要把 SFC 的 icon.vue 文件的实例类型返回出去：
~~~ts
import type Icon from './icon.vue'
export type IconInstance = InstanceType<typeof Icon>
~~~

TypeScript 中的 `InstanceType` 函数：该函数返回（构造） 由某个构造函数构造出来的实例类型组成的类型

### script setup 编写SFC组件

通过script setup 方式编写的 SFC 组件，导入刚刚写好的Props，要使用`defineProps`来声明props，声明的props也会自动暴露给模板，`defineProps` 会返回一个对象，其中包含了可以传递给组件的所有 props。

~~~ts
const props = defineProps(iconProps)

const style = computed<CSSProperties>(() => {
  if (!props.size && !props.color) return {}

  return {
    fontSize: isUndefined(props.size) ? undefined : addUnit(props.size),
    '--color': props.color,
  }
})
~~~

`v-bind="$attrs"`表示将父组件传递给子组件的所有属性都动态绑定到当前组件的属性上。`$attrs`是一个特殊的属性，它包含了父组件传递给子组件的非props属性。

### 组件注册

#### 局部注册

去到 play 目录下的 src 目录中的 App.vue 文件中把上面写的 Icon 组件进行引入测试，两种方式局部注册：
1. script setup直接import就可以使用
2. defineComponent 定义组件，需要再components中写上

#### 全局注册

Vue3组件库的实现原理：每一个组件安装一个插件，通过插件完成组件的全局注册。

需要给每一个组件都添加一个 `install` 方法，我们可以把这个方法进行封装成为一个公共方法。我们在 `packages/utils/vue/install.ts` 中添加以下代码：

~~~ts
import type { Plugin } from 'vue'
// 通过 Vue 提供的 Plugin 类型和传进来的组件类型 T 的集合进行确定我们的组件类型具有 Plugin 类型方法，如 install 方法
export type SFCWithInstall<T> = T & Plugin
export const withInstall = <T>(comp: T) => {
  ;(comp as SFCWithInstall<T>).install = function (app) {
    // 组件的注册名称参数暂时是写死了 ElIcon，在后面的小节，我们再详细说明如何进行设置动态组件名称
    app.component('ElIcon', comp as SFCWithInstall<T>)
  }
  return comp as SFCWithInstall<T>
}
~~~

`SFCWithInstall<T>`，返回一个交叉类型: 同时具有组件的类型和Plugin类型
`withInstall` 函数接受一个组件类型 T 作为参数，并返回一个具有 `install` 方法的组件类型 comp。在 `install` 方法中，组件被注册为全局组件，注册名称为 'ElIcon'。

`packages/components/icon/index.ts` 中的代码为：
~~~ts
import { withInstall } from '@cobyte-ui/utils'
import Icon from './src/icon.vue'
// 通过 withInstall 方法给 Icon 添加了一个 install 方法
const ElIcon = withInstall(Icon)
export default ElIcon
// 导出 Icon 组件的 props
export * from './src/icon'
~~~

接下来，按组件库的方式在 `play/main.ts` 中进行全局安装引入 `Icon` 组件。